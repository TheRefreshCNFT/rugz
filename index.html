<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      overflow: hidden;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    body, html {
      margin: 0 !important;
    }

    .modal {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: #555; padding: 20px; border-radius: 10px;
        display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
        box-shadow: 0 0 20px gold; z-index: 10;
    }
    .modal button {
        padding: 10px; background: #000; color: gold; border: none;
        font-weight: bold; cursor: pointer; box-shadow: 0 0 10px gold;
    }
  </style>
</head>
<body>
  <canvas id="pixelCanvas" style="object-fit: contain; position: absolute;"></canvas>
  <script>
  const message = "ðŸ”„"; //â‚¿ Update this variable with the desired word, character, number, etc.
  const pixelSize = 8;
  const numSpaces = 11;
  const numRows = 64;
  const frayLength = pixelSize * 5; // Adjust the length of the fray
  const frayCount = 10; // Adjust the number of frays
  const lW = 1;
  const backgroundColor = '#ffffff'; // Background color for the rug
  const textColor = '#3b88c3';//adjustColorBrightness('#0731a7', getRandomInt(-40, 40)); // Text color for the message
  const basePatternColor = "#ffffff"; // Base color for the rug pattern
  const borderColor = "#d8d8d8"; // Border color for the middle rug
  // Additional colors for pixelation
  const color1 = "#ffffff"; // Additional color 1
  const color2 = "#ffffff"; // Additional color 2
  const color3 = "#ffffff"; // Additional color 3

  const colorMap = {
    5: basePatternColor,
    6: textColor,
    9: 'transparent',
    10: backgroundColor,
    11: color1,
    12: color2,
    13: color3
  };

  var isAndroid = /Android/i.test(navigator.userAgent);
  var isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function adjustColorBrightness(color, amount) {
      const usePound = color[0] === "#";
      const num = parseInt(color.slice(1), 16);
      let r = (num >> 16) + amount;
      let g = ((num >> 8) & 0x00FF) + amount;
      let b = (num & 0x0000FF) + amount;

      if (r > 255) r = 255;
      else if (r < 0) r = 0;

      if (g > 255) g = 255;
      else if (g < 0) g = 0;

      if (b > 255) b = 255;
      else if (b < 0) b = 0;

      return (usePound ? "#" : "") + (r << 16 | g << 8 | b).toString(16).padStart(6, "0");
    }

    const canvas = document.getElementById("pixelCanvas");
    const ctx = canvas.getContext("2d");
    const canvasWidth = 1024;
    const rowLength = canvasWidth / pixelSize;
    const patternHeight = numRows * pixelSize;
    const rugPattern = generateRugPattern(numSpaces, numRows, rowLength);
    canvas.width = canvasWidth;
    canvas.height = patternHeight;
    canvas.style.width = "100vw";
    if (numRows <= 43) {
      canvas.style.height = "100vh";
    } else {
      const newVH = 100 - ((numRows - 43) * 0.1);
      canvas.style.height = `${newVH}vh`;
    }

    function generateRugPattern(numSpaces, numRows, rowLength) {
      const pattern = [];
      for (let row = 0; row < numRows; row++) {
        const rowPattern = [];
        for (let col = 0; col < rowLength; col++) {
          if (row === 0 || row === numRows - 1) {
            rowPattern.push(9); // Solid color for top and bottom rows
          } else if (row % 2 === 0) {
            if (col < numSpaces || col >= rowLength - numSpaces) {
              rowPattern.push(9); // Solid color for the ends of even rows
            } else {
              // Apply additional colors with a 40% chance
              if (Math.random() < 0.4) {
                const colorIndex = getRandomInt(11, 13);
                rowPattern.push(colorIndex);
              } else {
                rowPattern.push(5); // Solid pattern for the middle part of even rows
              }
            }
          } else {
            if (col < numSpaces || col >= rowLength - numSpaces) {
              rowPattern.push(9); // Transparent for the ends of odd rows
            } else {
              // Apply additional colors with a 40% chance
              if (Math.random() < 0.4) {
                const colorIndex = getRandomInt(11, 13);
                rowPattern.push(colorIndex);
              } else {
                rowPattern.push(5); // Solid pattern for the middle part of odd rows
              }
            }
          }
        }
        pattern.push(rowPattern);
      }

      return pattern.flat();
    }

    function drawPixelatedText(message, x, y, scale, textColor) {
      const offscreenCanvas = document.createElement('canvas');
      const offscreenCtx = offscreenCanvas.getContext('2d');
      offscreenCanvas.width = canvas.width;
      offscreenCanvas.height = canvas.height;

      // Draw the text on the offscreen canvas
      offscreenCtx.font = `${384 * scale}px Arial`;
      if (isAndroid) {
        offscreenCtx.font = `${320 * scale}px Arial`;
      }
      offscreenCtx.fillStyle = textColor;
      offscreenCtx.textAlign = "center";
      offscreenCtx.textBaseline = "middle";
      offscreenCtx.fillText(message, x * scale, y * scale);

      // Extract the pixel data of the text
      const textData = offscreenCtx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height);
      const pixels = textData.data;

      // Modify pixels to apply random opacity and brightness
      for (let i = 0; i < pixels.length; i += 4) {
        if (pixels[i + 3] > 0) { // Only modify non-transparent pixels
          // Randomize brightness
          const brightnessOffset = getRandomInt(-40, 40);
          pixels[i] = Math.min(255, Math.max(0, pixels[i] + brightnessOffset)); // Red
          pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1] + brightnessOffset)); // Green
          pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2] + brightnessOffset)); // Blue

          // Randomize opacity (apply to alpha channel)
          if (Math.random() < 0.5) { // 50% chance to reduce opacity
            pixels[i + 3] = pixels[i + 3] * getRandomInt(50, 100) / 100; // Random opacity 50-100%
          }
        }
      }

      // Put the modified pixel data back onto the offscreen canvas
      offscreenCtx.putImageData(textData, 0, 0);

      // Draw the offscreen canvas onto the main canvas
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(
        offscreenCanvas,
        0, 0, offscreenCanvas.width, offscreenCanvas.height,
        0, 0, canvas.width / scale, canvas.height / scale
      );
    }

    function drawPixelArtRug() {
      const rugStartX = numSpaces * pixelSize;
      const rugEndX = canvasWidth - numSpaces * pixelSize;
      const rugStartY = pixelSize;
      const rugEndY = canvas.height - pixelSize;

      for (let i = 0; i < rugPattern.length; i++) {
        const x = (i % rowLength) * pixelSize;
        const y = Math.floor(i / rowLength) * pixelSize;

        let color = getColorFromCode(rugPattern[i]);
        if ([5, 6, 11, 12, 13].includes(rugPattern[i])) {
          color = adjustColorBrightness(colorMap[rugPattern[i]], getRandomInt(-40, 40));
          ctx.fillStyle = color;
          ctx.fillRect(x, y, pixelSize, pixelSize);
        }

        // Apply brightness adjustment to frays
        if (rugPattern[i] === 5 || rugPattern[i] === 6) {
          color = adjustColorBrightness(colorMap[6], getRandomInt(-30, 30));//change colorMap[value] for frays
        }

        // Draw frayed ends for even rows
        if ((y / pixelSize) % 2 === 0) {
          if (x >= (rowLength - 13) * pixelSize) {
            drawRightFrayedEnd(x + pixelSize, y, color);  // Adjust the right side frays
          } else if (x < 13 * pixelSize) {
            drawLeftFrayedEnd(x, y, color);  // Adjust the left side frays
          }
        }
      }

      // Draw the border
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = lW; // Set the border width
      ctx.strokeRect(rugStartX, rugStartY, rugEndX - rugStartX, rugEndY - rugStartY);

      const centerX = canvas.width / 2;
      var textY; // Declare

      if (isAndroid) {
          textY = drawPixelatedText(message, centerX, canvas.height / 1.85, 0.125, textColor);
      } else if (isIOS) {
          textY = drawPixelatedText(message, canvas.width / 2.01, canvas.height / 1.98, 0.125, textColor);
      } else {
          textY = drawPixelatedText(message, centerX, canvas.height / 1.8, 0.125, textColor);
      }
    }

    function drawRightFrayedEnd(x, y, color) {
      const startX = x + pixelSize;
      for (let i = 0; i < frayCount; i++) {
        const offset = getRandomInt(-1, 1) * (pixelSize / 4);
        const angle = (Math.PI / 6) - (Math.random() * (Math.PI / 6));
        const endX = startX + Math.cos(angle) * frayLength;
        const endY = y + Math.sin(angle) * frayLength + offset;

        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = color;
        ctx.stroke();
      }
    }

    function drawLeftFrayedEnd(x, y, color) {
      const startX = x - pixelSize;
      for (let i = 0; i < frayCount; i++) {
        const offset = getRandomInt(-1, 1) * (pixelSize / 4);
        const angle = (Math.PI / 6) - (Math.random() * (Math.PI / 6));
        const endX = startX - Math.cos(angle) * frayLength;
        const endY = y + Math.sin(angle) * frayLength + offset;

        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = color;
        ctx.stroke();
      }
    }

    function getColorFromCode(code) {
      return colorMap[code];
    }

    drawPixelArtRug();

    let timer;
        canvas.addEventListener("click", e => e.detail === 1 && (timer = setTimeout(() => location.reload(), 300)));

        canvas.addEventListener("dblclick", () => {
          clearTimeout(timer);
            showModal();
        });

        function showModal() {
            const options = ['1k', '1kt', '2k', '2kt', '3k', '3kt', '4k', '4kt', '8k', '8kt', '16k', '16kt'];
            const modal = document.createElement('div');
            modal.className = 'modal';
            if (modal) {
              modal.style.background = "#000";
              modal.style.boxShadow = `0 0 10px ${textColor}`;
            }
            options.forEach(opt => {
                const btn = document.createElement('button');
                btn.textContent = opt;
                btn.onclick = () => {
                    document.body.removeChild(modal);
                    scaleCanvas(parseInt(opt), opt.includes('t'));
                };
                modal.appendChild(btn);
                // Apply the styles dynamically
                if (btn) {
                  btn.style.background = "#000";
                  btn.style.color = textColor;
                  btn.style.boxShadow = `0 0 10px ${textColor}`;
                }
              });
            document.body.appendChild(modal);
        }

        function scaleCanvas(multiplier, transparent) {
            const upscaleResolution = 1024 * multiplier;

            // Create an offscreen canvas
            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d', { alpha: transparent });
            offscreenCanvas.width = upscaleResolution;
            offscreenCanvas.height = upscaleResolution;
            const offscreenCanvasBlk = document.createElement('canvas');
            const offscreenCtxBlk = offscreenCanvasBlk.getContext('2d', { alpha: transparent });
            offscreenCtxBlk.fillStyle = '#000000'; // Black background
            offscreenCtxBlk.fillRect(0, 0, upscaleResolution, upscaleResolution);

            // Calculate scaling factors
            const scale = upscaleResolution / Math.min(canvas.width, canvas.height);
            const scaledWidth = canvas.width * scale;
            const scaledHeight = canvas.height * scale;
            const offsetX = (upscaleResolution - scaledWidth) / 2;
            const offsetY = (upscaleResolution - scaledHeight) / 2;

            // Set the background color
            if (!transparent) {
              // Draw the content of the main canvas onto the offscreen canvas
                offscreenCtxBlk.drawImage(canvas, offsetX, offsetY, scaledWidth, scaledHeight);
                offscreenCanvasBlk.width = canvas.width * multiplier;
                offscreenCanvasBlk.height = canvas.height * multiplier;
                offscreenCtxBlk.scale(multiplier, multiplier);
                offscreenCtxBlk.drawImage(canvas, 0, 0);

                // Save the image as a PNG
                const link = document.createElement('a');
                link.download = `RUGZ_${multiplier}k${transparent ? '_transparent' : ''}.png`;
                link.href = offscreenCanvasBlk.toDataURL('image/png');
                link.click();
            } else {
                offscreenCtx.clearRect(0, 0, upscaleResolution, upscaleResolution); // Transparent background
                offscreenCtx.drawImage(canvas, offsetX, offsetY, scaledWidth, scaledHeight);
                offscreenCanvas.width = canvas.width * multiplier;
                offscreenCanvas.height = canvas.height * multiplier;
                offscreenCtx.scale(multiplier, multiplier);
                offscreenCtx.drawImage(canvas, 0, 0);

                // Save the image as a PNG
                const link = document.createElement('a');
                link.download = `RUGZ_${multiplier}k${transparent ? '_transparent' : ''}.png`;
                link.href = offscreenCanvas.toDataURL('image/png');
                link.click();
            }
            return;
        }


    function releaseCanvas(c){c.width=1;c.style.width="1vw";c.height=1;c.style.height="1vh";const x=c.getContext("2d");x&&x.clearRect(0,0,1,1);c.remove()}window.addEventListener("pagehide",()=>{Array.prototype.slice.call(document.getElementsByTagName("canvas")).forEach(releaseCanvas)});
  </script>
</body>
</html>
