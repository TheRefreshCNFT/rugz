<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      overflow: hidden;
      background: white;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    body, html {
      margin: 0 !important;
    }
  </style>
</head>
<body>
  <canvas id="pixelCanvas" style="object-fit: contain; position: absolute;"></canvas>
  <script>
    function releaseCanvas(canvas) {
      canvas.width = 1;
      canvas.style.width = "1vw";
      canvas.height = 1;
      canvas.style.height = "1vh";
      const ctx = canvas.getContext('2d');
      ctx && ctx.clearRect(0, 0, 1, 1);
      canvas.remove();
    }

    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function adjustColorBrightness(color, amount) {
      const usePound = color[0] === "#";
      const num = parseInt(color.slice(1), 16);
      let r = (num >> 16) + amount;
      let g = ((num >> 8) & 0x00FF) + amount;
      let b = (num & 0x0000FF) + amount;

      if (r > 255) r = 255;
      else if (r < 0) r = 0;

      if (g > 255) g = 255;
      else if (g < 0) g = 0;

      if (b > 255) b = 255;
      else if (b < 0) b = 0;

      return (usePound ? "#" : "") + (r << 16 | g << 8 | b).toString(16).padStart(6, "0");
    }

    const canvas = document.getElementById("pixelCanvas");
    const ctx = canvas.getContext("2d");
    const canvasWidth = 1024;
    const pixelSize = 8;
    const rowLength = canvasWidth / pixelSize;
    const numSpaces = 11;
    const numRows = 63;
    const frayLength = pixelSize * 5; // Adjust the length of the fray
    const frayCount = 10; // Adjust the number of frays

    const patternHeight = numRows * pixelSize;
    canvas.width = canvasWidth;
    canvas.height = patternHeight;
    canvas.style.width = "100vw";
    if (numRows <= 43) {
      canvas.style.height = "100vh";
    } else {
      const newVH = 100 - ((numRows - 43) * 0.1);
      canvas.style.height = `${newVH}vh`;
    }

    const backgroundColor = "#615bfe"; // Background color for the rug
    const textColor = "#0731a7"; // Text color for the message
    const basePatternColor = "#ffffff"; // Base color for the rug pattern

    // Additional colors for pixelation
    const color1 = "#ffffff"; // Additional color 1
    const color2 = "#ffffff"; // Additional color 2
    const color3 = "#ffffff"; // Additional color 3

    const colorMap = {
      5: basePatternColor,
      6: textColor,
      9: 'transparent',
      10: backgroundColor,
      11: color1,
      12: color2,
      13: color3
    };

    const borderColor = "#d8d8d8"; // Border color for the middle rug
    const message = "₳"; //₿ Update this variable with the desired word, character, number, etc.
    const rugPattern = generateRugPattern(numSpaces, numRows, rowLength);

    function generateRugPattern(numSpaces, numRows, rowLength) {
      const pattern = [];
      for (let row = 0; row < numRows; row++) {
        const rowPattern = [];
        for (let col = 0; col < rowLength; col++) {
          if (row === 0 || row === numRows - 1) {
            rowPattern.push(9); // Solid color for top and bottom rows
          } else if (row % 2 === 0) {
            if (col < numSpaces || col >= rowLength - numSpaces) {
              rowPattern.push(9); // Solid color for the ends of even rows
            } else {
              // Apply additional colors with a 40% chance
              if (Math.random() < 0.4) {
                const colorIndex = getRandomInt(11, 13);
                rowPattern.push(colorIndex);
              } else {
                rowPattern.push(5); // Solid pattern for the middle part of even rows
              }
            }
          } else {
            if (col < numSpaces || col >= rowLength - numSpaces) {
              rowPattern.push(9); // Transparent for the ends of odd rows
            } else {
              // Apply additional colors with a 40% chance
              if (Math.random() < 0.4) {
                const colorIndex = getRandomInt(11, 13);
                rowPattern.push(colorIndex);
              } else {
                rowPattern.push(5); // Solid pattern for the middle part of odd rows
              }
            }
          }
        }
        pattern.push(rowPattern);
      }

      return pattern.flat();
    }

    function drawPixelatedText(message, x, y, scale, color) {
      const offscreenCanvas = document.createElement('canvas');
      const offscreenCtx = offscreenCanvas.getContext('2d');
      offscreenCanvas.width = canvas.width;
      offscreenCanvas.height = canvas.height;

      offscreenCtx.font = `${512 * scale}px Arial`;
      offscreenCtx.fillStyle = color;
      offscreenCtx.textAlign = "center";
      offscreenCtx.textBaseline = "middle";
      offscreenCtx.fillText(message, x * scale, y * scale);

      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(offscreenCanvas, 0, 0, offscreenCanvas.width, offscreenCanvas.height, 0, 0, canvas.width / scale, canvas.height / scale);
    }

    function drawPixelArtRug() {
      const rugStartX = numSpaces * pixelSize;
      const rugEndX = canvasWidth - numSpaces * pixelSize;
      const rugStartY = pixelSize;
      const rugEndY = canvas.height - pixelSize;

      for (let i = 0; i < rugPattern.length; i++) {
        const x = (i % rowLength) * pixelSize;
        const y = Math.floor(i / rowLength) * pixelSize;

        let color = getColorFromCode(rugPattern[i]);
        if ([5, 6, 11, 12, 13].includes(rugPattern[i])) {
          color = adjustColorBrightness(colorMap[rugPattern[i]], getRandomInt(-40, 40));
          ctx.fillStyle = color;
          ctx.fillRect(x, y, pixelSize, pixelSize);
        }

        // Apply brightness adjustment to frays
        if (rugPattern[i] === 5 || rugPattern[i] === 6) {
          color = adjustColorBrightness(colorMap[6], getRandomInt(-30, 30));
        }

        // Draw frayed ends for even rows
        if ((y / pixelSize) % 2 === 0) {
          if (x >= (rowLength - 13) * pixelSize) {
            drawRightFrayedEnd(x + pixelSize, y, color);  // Adjust the right side frays
          } else if (x < 13 * pixelSize) {
            drawLeftFrayedEnd(x, y, color);  // Adjust the left side frays
          }
        }
      }

      // Draw the border
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 0.5; // Set the border width
      ctx.strokeRect(rugStartX, rugStartY, rugEndX - rugStartX, rugEndY - rugStartY);

      // Draw the pixelated message in the center of the rug
      drawPixelatedText(message, canvas.width / 2, canvas.height / 1.7, 0.1, textColor);
    }

    function drawRightFrayedEnd(x, y, color) {
      const startX = x + pixelSize;
      for (let i = 0; i < frayCount; i++) {
        const offset = getRandomInt(-1, 1) * (pixelSize / 4);
        const angle = (Math.PI / 6) - (Math.random() * (Math.PI / 6));
        const endX = startX + Math.cos(angle) * frayLength;
        const endY = y + Math.sin(angle) * frayLength + offset;

        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = color;
        ctx.stroke();
      }
    }

    function drawLeftFrayedEnd(x, y, color) {
      const startX = x - pixelSize;
      for (let i = 0; i < frayCount; i++) {
        const offset = getRandomInt(-1, 1) * (pixelSize / 4);
        const angle = (Math.PI / 6) - (Math.random() * (Math.PI / 6));
        const endX = startX - Math.cos(angle) * frayLength;
        const endY = y + Math.sin(angle) * frayLength + offset;

        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = color;
        ctx.stroke();
      }
    }

    function getColorFromCode(code) {
      return colorMap[code];
    }

    drawPixelArtRug();

    let timer;
    document.querySelector("canvas").addEventListener('click', event => {
      if (event.detail === 1) {
        timer = setTimeout(() => {
          location.reload();
        }, 200)
      }
    });

    document.querySelector("canvas").addEventListener("dblclick", function () {
      clearTimeout(timer);
      const link = document.createElement('a');
      link.download = 'F5rugz.png';
      link.href = canvas.toDataURL();
      link.click();
    });
  </script>
</body>
</html>
